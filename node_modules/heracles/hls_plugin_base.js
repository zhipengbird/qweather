const NATIVE_RESULT_CODE_OK = 0

const NATIVE_RESULT_CODE_PLUGIN_NOT_EXIST = -1001

const NATIVE_RESULT_CODE_PLUGIN_METHOD_NOT_EXIST = -1002

const NATIVE_RESULT_CODE_PLUGIN_URL_NOT_INVALIDATE = -1003

const NATIVE_RESULT_CODE_BIZ_ERROR = -1004

/**
 * 通过promise调用客户端方法
 * @param {Object} module - 插件命名空间
 * @param {Object} method - 插件具体方法
 * @param {Object} params - 方法对应参数
 * @param {Object} msg - 方法作用描述
 */
export function callNative(module, method, params, msg) {

	let event = "hlsapi://" + module + '/' + method

	// #ifdef APP-PLUS
	return new Promise(function(resolve, reject) {
		uni.sendNativeEvent(event, {
			msg: msg,
			data: params
		}, ret => {
			let nativeMsg = event + '=>' + '宿主App回传的数据：' + ret;
			console.log(nativeMsg);
			
			let resp = JSON.parse(ret)

			if (resp.code == 0) {
				resolve(resp.data)
			} else {
				let error = new Error(resp.msg || 'Error')
				error.data = resp.data
				error.code = resp.code
				reject(error)
			}
		})
	})
	// #endif

	// #ifdef H5

	return new Promise(function(resolve, reject) {

		const timestamp = new Date().getTime()
		let callbackMethod = "__HLS_CALLBACK__" + timestamp
		params['callback'] = callbackMethod

		window[callbackMethod] = function(res) {

			let nativeMsg = event + '=>' + 'H5模式: 宿主App回传的数据：' + JSON.stringify(res);
			console.log(nativeMsg);

			if (res.code == 0) {
				resolve(res.data)
			} else {
				let error = new Error(res.msg || 'Error')
				error.data = res.data
				error.code = res.code
				reject(error)
			}
		}

		let p = JSON.stringify(params)
		let finalUrl = event + '?p=' + encodeURIComponent(p)

		console.log("H5模式: 发起伪协议调用: ", finalUrl)

		// 调用 iOS 使用
		if (typeof window.webkit !== 'undefined') {
			window.webkit.messageHandlers.callHeracles.postMessage(finalUrl);
		}

		// 调用 android 使用
		if (typeof window.HeraclesBridge !== 'undefined') {
			window.HeraclesBridge.callNativeMethod(finalUrl); // HeraclesBridge 安卓注册到 H5，直接使用便可
		}
	})

	// #endif
}

/**
 * 需要持续回调的时候用这个方式
 * 这个方法可以让客户端多次执行回调，然后接收
 * @param {Object} module
 * @param {Object} method
 * @param {Object} params
 * @param {Object} msg
 * @param {Object} successCallback
 * @param {Object} failedCallback
 */
export function callNativeKeepCallback(module, method, params, msg, successCallback, failedCallback) {

	let event = "hlsapi://" + module + '/' + method

	// #ifdef APP-PLUS
	uni.sendNativeEvent(event, {
		msg: msg,
		data: params
	}, ret => {
		let nativeMsg = event + '=>' + '宿主App回传的数据：' + ret;
		let resp = JSON.parse(ret)

		if (resp.code == 0) {
			if (typeof successCallback == 'function') {
				successCallback(resp.data)
			}
		} else {
			let error = new Error(resp.msg || 'Error')
			error.data = resp.data
			error.code = resp.code

			if (typeof failedCallback == 'function') {
				failedCallback(error)
			}
		}
	})
	// #endif

	// #ifdef H5

	const timestamp = new Date().getTime()
	let callbackMethod = "__HLS_CALLBACK__" + timestamp
	params['callback'] = callbackMethod

	window[callbackMethod] = function(res) {

		let nativeMsg = event + '=>' + 'H5模式: 宿主App回传的数据：' + JSON.stringify(res);
		console.log(nativeMsg);

		if (res.code == 0) {
			if (typeof successCallback == 'function') {
				successCallback(res.data)
			}
		} else {
			let error = new Error(res.msg || 'Error')
			error.data = res.data
			error.code = res.code

			if (typeof failedCallback == 'function') {
				failedCallback(error)
			}
		}
	}

	let p = JSON.stringify(params)
	let finalUrl = event + '?p=' + encodeURIComponent(p)

	console.log("H5模式: 发起伪协议调用: ", finalUrl)

	// 调用 iOS 使用
	if (typeof window.webkit !== 'undefined') {
		window.webkit.messageHandlers.callHeracles.postMessage(finalUrl);
	}

	// 调用 android 使用
	if (typeof window.HeraclesBridge !== 'undefined') {
		window.HeraclesBridge.callNativeMethod(finalUrl); // HeraclesBridge 安卓注册到 H5，直接使用便可
	}

	// #endif
}